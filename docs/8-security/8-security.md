## Lab 8: Login Security

1. Up to now we had login security for the Admin module disabled. Inspect /admin/login/index.pug, and look for 'sb.redirect('/admin/home/'). Comment it out. Ensure the API service is running. In a browser, return to the <a href='http://localhost:8091/' target='_blank'>home page</a>, and click the 'Admin' menu item to see the login prompt. Use 'demo':'demo' as username:password and click 'Login'. In VS Code, return to /admin/login/index.pug. See how we open the modal dialog, bind the form and register the form submit. Modal dialogs are natively supported by the Chrome browser. We use a 'polyfill' (loaded in /_js/admin.js) for compatibility with other browsers (Edge and IE need a little bit of CSS tweaking). LoginBusiness 'login()' contacts the API server (it could be a different server or service, dedicated to authentication). If the credentials match, LoginBusiness receives an 'OK' response, and we redirect to /admin/home/. If an authentication error is received, we display it in a div with id 'error' on the page.

2. Along with the 'OK' response, the API server returned a 'token'. This could be any String; we use JSON format. We store the token as a cookie (name: 'auth') in the browser. After the initial login, we use this token on all pages and for all API calls that require auhentication. While we could have kept username and password as a cookie instead, the advantage of using a token is that it can be heavily encoded (by the server). For maximum security and defense against network sniffing, the token could even be changed on every request.

3. To protecte the Linkblog pages with a login, open /admin/linkblog/index.pug and /detail.pug and uncomment //sb.ensureLogin(...). This function simply checks for the existence of the 'auth' cookie. If this cookie doesn't exist, it means that the user has not logged in, and he is redirected to the login screen. We destroy the 'auth' cookie on logout; see 'script.' in /admin/logout/index.pug. Logout is triggered when clicking the admin menu 'Logout' item.

4. For additional security, we send the token along when we make requests to the API server. If the API server is configured to require authentication, we ensure that the specific token received allows reading or writing the data before returning the data. If the token is not valid, we let the API service return a 403 error. When LinkblogBusiness receives such an error, we show an alert and redirect to the login page. Open /bsrv/config/ApiConfig.js to configure which API calls are to be secured. In the line for 'get REQUIRE_AUTH', uncomment 'write' so that it reads 'linkblog: ['write']'. Restart the server in the terminal window. This activates the token check in /bsrv/scode/route/LinkblogService.js following 'router.post('. The class TokenAuth contains our very simple Authentication functionalities: validate that username:password match demo:demo, and token matches "abc". 

5. You just activated token security for the Linkblog save function. Let's follow how to token is passed to the API. In /admin/linkblog/detail.pug, with '$('#form1').submit({auth: Cookies.get('auth')}, sb.save)' we instruct to include the auth cookie as event data when calling LinkblogBusiness.save. In LinkblogBusiness 'save', we pass it on to the DAO in 'sb.linkblogDao.update(formData, e.data.auth)'. this continues through BDS.js update, \_post and fetch_ functions, where the token is converted to a JSON stirng and passed to the API as 'X-JToken' header. If configured as described above, in /bsrv/scode/route/LinkblogService.js the API reads this header and validates the token using by calling '/bsrv/scode/route/ds/TokenAuth.js 'isTokenValidPromise'. 
Inspect this function. The returned promise throws an 'invalid token' error in the case of failure, which causes LinkblogService to abandon the update request and return a 403 error 'Forbidden'.

6. Reopen /admin/linkblog/LinkblogBusiness.js and find 'const _updatePromise'. Here follows what happens in the UI as a result of the update attempt. If the update/save was successful, we redirect to the linkblog list page. If it failed because the token did not validate, show an alert and redirect to the login page. In case of other failures, simply show an alert. If you wish to simulate the errors, go to /admin/linkblog/detail.pug and make it send an invalid token with '$('#form1').submit({auth: 'xyz'}, sb.save)'. Revert to ' $('#form1').submit({auth: Cookies.get('auth')}, sb.save)' when done. Since our linkblog is expected to be public, we didn't implement authentication for the linkblogDAO.selectList API call, but this could easily be added.

7. This Lab demonstrated the fundamentals of authentication flows. A 'real life' authentication provider would likely be more advanced than TokenAuth.js. Tokens might need to be encoded and decoded. A production implementation might access a database of credentials, an in-memory database of valid tokens, or an asynchronously called external authentication service that may return its own promises for credential and token validations. 

