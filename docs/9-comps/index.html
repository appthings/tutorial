<!DOCTYPE html>
<html lang="en-us">
  <head>
    <base href="/tutorial/">
    <title>Web Components</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="description" content="">
    <link rel="icon" href="./favicon.ico">
    <script src="//code.jquery.com/jquery-3.2.1.slim.min.js"></script>
    <script src="https://cdn.rawgit.com/topseed/topseed-turbo/master/vendor/loadjs.min.js"></script>
    <script src="https://cdn.rawgit.com/topseed/topseed-turbo/master/setup/setup-3.2.1.js"></script>
    <script src="./_js/main.js" async=""></script>
    <style>body {opacity: 0.1}</style>
  </head>
  <body>
    <link rel="stylesheet" href="./_sass/main.css" lazyload="1">
    <div id="appbar">
      <div id="appbar--brand" onclick="openDrawer()">&nbsp; ☰ &nbsp;<span class="mui--hidden-xs">Topseed&trade; Tutorial</span></div>
      <ul id="appbar--menu">
        <li><a href="./0-agenda/">Agenda</a></li>
        <li><a href="./1-helloWorld/">One</a></li>
        <li><a href="./2-theBasics/">Two</a></li>
        <li><a href="./3-goLive/">Three</a></li>
        <li><a href="./4-appShell/">Four</a></li>
        <li><a href="./5-amp/">Five</a></li>
        <li><a href="./6-read/">Six</a></li>
        <li><a href="./7-write/">Seven</a></li>
        <li><a href="./8-security/">Eight</a></li>
        <li><a href="./9-comps/">Nine			</a></li>
      </ul>
    </div>
    <div id="sidedrawer" onclick="closeDrawer()">
      <div id="sidedrawer--brand">&nbsp; ☰ Topseed&trade; Tutorials</div>
      <div class="mui-divider"></div>
      <ul id="sidedrawer--menu">
        <li><a href="./0-agenda/">Agenda</a></li>
        <li><a href="./1-helloWorld/">1: Hello World</a></li>
        <li><a href="./2-theBasics/">2: The Basics</a></li>
        <li><a href="./3-goLive/">3: Golive</a></li>
        <li><a href="./4-appShell/">4: AppShell</a></li>
        <li><a href="./5-amp/">5: AMP and Node.js</a></li>
        <li><a href="./6-read/">6: UI Reading from API	</a></li>
        <li><a href="./7-write/">7: UI Writing to API</a></li>
        <li><a href="./8-security/">8: Login Security</a></li>
        <li><a href="./9-comps/">9: Web Components				</a></li>
      </ul>
    </div>
    <script>
      function openDrawer(px, e) {
      	$('#sidedrawer').css('transform', 'translateX(201px)')
      }
      function closeDrawer(e) {
      	$('#sidedrawer').css('transform', 'translateX(0px)')
      }			
    </script>
    <div id="content-wrapper">
      <div class="mui-container-fluid"><h2 id="lab-9-standard-web-components-and-their-communication">Lab 9: Standard Web Components and their Communication</h2>
<ol>
<li><p>The quest for the web equivalent of &#39;Legos&#39; has been going on for a while. Legos are composable: you can connect pieces in different ways. They are reusable: the same kind of piece can be used in multiple places. Legos are also modular: you can connect one assembly to another one. Unlike Legos <a href='https://www.kickstarter.com/projects/1068475467/brixo-building-blocks-meet-electricity-and-iot' target='_blank'>(mostly)</a>, however, components for the web also need to be able to communicate with each other and with the outside world. Finally, web components need to be insulated (in Lego terms, the color of one item must not &#39;bleed&#39; into others). CSS &#39;bleed&#39; has been a particular problem of older web component frameworks. To find an overall solution for great web components is not trivial, and many attempts have been made to achieve the holy grail of component-based development for the web.</p>
</li>
<li><p>In reality, component frameworks have had a short half-life. The last years has seen a rapid succession of candidates to be considered &#39;the best&#39;: Backbone, Knockout, Ember, Angular, Angular 2, React, Vue, Riot and Polymer. Find a comparison of component frameworks at <a href='http://jeffcarp.github.io/frontend-hyperpolyglot/' target='_blank'>http://jeffcarp.github.io/frontend-hyperpolyglot/</a>. History shows that what you would pick today is likely not what you would pick 18 months from now. Assuming you don&#39;t want to start from scratch and rewrite everything every 18 months, that presents you with a great challenge of how to write applications that you can expect to be both maintainable and future-safe.</p>
</li>
<li><p>Our best practice to deal with the evolving landscape of web components is to write webapps that are structured in a &#39;component-framework-agnostic&#39; way, where you can potentially keep existing components around, but develop new components using a newer component framework. We achieve this by avoiding the use of the two kinds of common component framework features that create unattractive &#39;lock-in&#39;: custom navigation mechanisms (routers) and framework-specific component communication implementations. We use the browser&#39;s great native navigation mechanisms (URL and browser history) as shown in Lab 4, and framework-agnostic component communication as implemented in the sample project shown below. </p>
</li>
<li><p>There is, however, light at the end of the tunnel: a W3C standard for web components appears to be forming.  Read about Standard Web Components <a href='https://en.wikipedia.org/wiki/Web_Components' target='_blank'>here</a>. The Chrome browser already supports Standard Web Components natively, so there is nothing extra to load, and the polyfills for the other browers are lean and fast. The most recent contender for &#39;the best&#39; component framework, Polymer, is actually developed on top of this emerging standard, by the same people at Google in charge of the standard reference implementation. We use standard web components as the default component framework for this Lab. However, our architectural concepts can also be applied when using other frameworks. May we tempt you to write a sample integration for your favorite component framework and contribute it to topseed?</p>
</li>
<li><p>Among other things, newer component frameworks solve the problem of CSS bleeding by using the &#39;Shadow DOM&#39; construct. To work with web components you should understand Shadow DOM; read this <a href='https://www.html5rocks.com/en/tutorials/webcomponents/shadowdom/' target='_blank'>good introduction</a>. We prefer it over the more recent introduction 
<a href='https://developers.google.com/web/fundamentals/getting-started/primers/shadowdom' target='_blank'>here</a>. &#39;Templates&#39; and &#39;HTML Imports&#39; are other Standard Web Component features which will become clear with the examples in this Lab. Finally, there is a &#39;Custom Element&#39; API to create new HTML tags. However, the implementation of this API uses &#39;class&#39; which is not supported by Internet Explorer. We will use the Custom Element API once IE has lost its remaining popularity, or when we can rule out IE in a corporate app. </p>
</li>
<li><p>Download and unzip topseed-webcomps-master.zip from <a href='https://github.com/topseed/topseed-webcomps' target='_blank'>here</a> to your location of choice on your developer machine. Open the project in VS Code. Add the project root folder in Prepros, but deactivate compilation of Pug (Jade) for this project. In this project, Node.js compiles pug files on the fly when responding to HTTP requests so we don&#39;t need Preprose to precompile them. See the function &#39;pugComp&#39; in /demo-srv/util/Decider.js. Since we cache generated HTML responses in the CDN, there is practically no impact on production performance, but the development project is a lot cleaner. </p>
</li>
<li><p>In VS Code, open Terminal Shell (Ctrl+Shift+`), type &#39;cd demo-srv [Enter]&#39;, do the &#39;npm install [Enter]&#39; and then &#39;node index [Enter]&#39;.
You should see console output &#39;Web server listening at <a href="http://localhost:9081">http://localhost:9081</a>&#39;. In the browser, <a href='http://localhost:9081' target='_blank'>navigate to it</a>, and visit Dashboard, List, Circle, Prelist and List menu items. When writing a component, we always advise to make things work outside of a component first. &#39;Prelist&#39; is a non-component list page. In VS Code, inspect its /demo-srv/root/page/list-0/index.pug. Similar to the admin linkblog in tutorial 6, this page uses &#39;/page/list/ListBusiness.js&#39; to load a list from a JSON response promise. For data binding, ListBusiness.list() uses doT.js, a fast &#39;moustache-style&#39; template library. The doT template is embedded in the page html as a script of type &#39;text/x-dot-template&#39;. Inspect ListBusiness.js, beginning with &#39;var templateText&#39; to see the JavaScript used to render the template with data and attach it to &#39;#myList&#39; in the page. You can read more about doT <a href='http://www.javascriptoo.com/dot-js' target='_blank'>here</a>.</p>
</li>
<li><p>Inspect the component version of the list page at /demo-srv/root/page/list/index.pug. It has a custom element in the html named &#39;list-el&#39;. Custom elements must include a &#39;-&#39; (dash) in the tag name. The doT template has disappeard. The page &#39;script.&#39; loads ListBusiness.js and the List component definition from the &#39;HTML Import&#39; /_webComps/List.html, and then calls sb.compList() to render an instance of the component. In /page/list/ListBusiness.js, compare the function &#39;compList&#39; with the function &#39;list&#39; used by the non-component version. In this example, the &#39;compList&#39; function obtains the component instance with &#39;document.querySelector&#39; and calls its list(values) function. We always pass data to a component, instead of making the component load data. This keeps the component simpler and more manageable. As a result of using a component, both the page and ListBusiness are somewhat cleaner; &#39;JavaScript mess&#39; is hidden inside the component.</p>
</li>
<li><p>Inspect the dashboard page at /demo-srv/root/page/dashboard/index.pug for an example of using multiple components in one page. Find the reused &#39;list-el&#39;, as well as &#39;circle-el&#39; and &#39;gauge-el&#39; in the HTML. In the script function &#39;UIinit&#39;, the &#39;circle&#39; and &#39;gauge&#39; components are used in a simplified way, without a &#39;Business.js&#39; that would load live data for the component. The circle and gauge components are loaded from absolute URLs. This means that components can easily be shared across different web projects.</p>
</li>
<li><p>Optional: Inspect the list component implementation at /demo-srv/root/_webComps/List.pug. You will find the Standard Web Component &#39;template&#39; tag that includes the node #myList previously seen in the non-component page, as well as the x-dot-template. The &#39;script.&#39; section creates a HTMLElement prototype named &#39;ListEl&#39;, specifies to attache the insulated shadow DOM (using TW.attachShadow) when an actual component instance is created from the prototype (&#39;createdCallback&#39;), and registers the element prototype as a custom element with the DOM, using TW.registerCustomElement. Also see the ListEl.list function implementation which places the databinding result into the &#39;#myList&#39; node in the shadow DOM. (You can find the the &#39;TW.&#39; helper library function implementations in /demo-srv/root/_js/setup-3.4.js.) When comparing Prelist and List in a Chrome browser, you may notice that the styling of the links is different. This is because the component version is insulated from the global CSS. As of the time of writing, CSS still bleeds in both directions in Firefox and Edge. For us this is not catastrophic because we already avoid CSS namespace collisions by using BEM syntax when naming our own component styles. Remaining potential issues with third party styles used inside components (example: gauge) will disappear once all browsers natively support Standard Web Components. Read <a href='https://csswizardry.com/2013/01/mindbemding-getting-your-head-round-bem-syntax/' target='_blank'>this</a> to lean how to use BEM; it is a best practice even when not using components. Hint: use the unique component name (&#39;list-el&#39;) as BEM &#39;block&#39;.</p>
</li>
<li><p>It is possible to write components that bleed &#39;on purpose&#39;, by making components use actual DOM vs shadow DOM. You may choose to do this if you have a well-managed, globally applicable CSS regime (ideally using BEM throughout), and are not worried about 3rd party style bleeding. Or you can use SASS to bring global CSS styles into the component, analog to using mainA.css inline with AMP as shown in tutorial 5.</p>
</li>
<li><p>We like creating and using components when it make us more productive, and the code becomes more maintainable. We decide this per use case. Be your own judge!</p>
</li>
</ol>

        <div class="mui--text-left"><a class="mui-btn" href="./0-agenda/">Return to Agenda</a></div>
      </div>
      <script>
        TS.onAppReady(UIinit)
        function UIinit() {
        	console.log('9-comps')
        }
        
      </script>
    </div>
    <div id="footer">
      <div id="footer_div"><a href="https://gitter.im/topseed/Lobby" target="_blank">Forum </a>
        <div id="footer_div--right"><a href="https://github.com/topseed/topseed" target="_blank">Kitchen Sink</a></div>
      </div>
    </div>
  </body>
</html>